#include "aes.h"
#include "bit.h"
#include "mem.h"
#include <assert.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#define IV_LEN_BYTES 12
#define BLOCK_LEN_BYTES 16
#define TAG_LEN_BYTES 16

__attribute__((always_inline)) static inline void
GcmMul(const uint8_t X[16], const uint8_t Y[16], uint8_t out[16]) {
    uint8_t Z[16] = {0};
    uint8_t V[16];

    ft_memcpy(V, Y, 16);

    for (int i = 0; i < 128; ++i) {
        int bit = (X[i / 8] >> (7 - (i % 8))) & 1;

        if (bit == 1) {
            for (int j = 0; j < 16; ++j) {
                Z[j] ^= V[j];
            }
        }

        int lsb = V[15] & 1;

        for (int j = 15; j > 0; --j) {
            V[j] = (V[j] >> 1) | ((V[j - 1] & 1) << 7);
        }
        V[0] >>= 1;

        if (lsb == 1) {
            V[0] ^= 0xe1;
        }
    }

    ft_memcpy(out, Z, 16);
}

__attribute__((always_inline)) static inline void
GHASH(const uint8_t H[16], const uint8_t *const data, size_t len, uint8_t out[16]) {
    uint8_t Y[16] = {0};

    for (size_t i = 0; i < len; i += 16) {
        uint8_t block[16] = {0};
        size_t block_len = (len - i) > 16 ? 16 : (len - i);

        ft_memcpy(block, data + i, block_len);

        for (int j = 0; j < 16; ++j) {
            Y[j] ^= block[j];
        }

        GcmMul(Y, H, Y);
    }

    ft_memcpy(out, Y, 16);
}

__attribute__((always_inline)) static inline void
GHASH_block(uint8_t Y[16], const uint8_t block[16], const uint8_t H[16]) {
    for (int i = 0; i < 16; ++i) {
        Y[i] ^= block[i];
    }
    GcmMul(Y, H, Y);
}

// `Y->msg.data` is expected to have at least `X->msg.len` bytes allocated.
// `X->msg.data` and `Y->msg.data` may overlap.
__attribute__((always_inline)) static inline void
GCTR(const uint8_t *const restrict ICB, const Aes256Data *const X, Aes256Data *const Y) {
    if (X->msg.len == 0) {
        ft_memcpy(Y->key, X->key, sizeof(X->key));
        ft_memcpy(Y->expanded_key, X->expanded_key, 60 * sizeof(uint32_t));
        Y->msg.len = 0;
        Y->msg.data = NULL;
        return;
    }

    const size_t n_complete_blocks = X->msg.len / BLOCK_LEN_BYTES;
    const size_t partial_block_len = X->msg.len % BLOCK_LEN_BYTES;
    uint8_t CB[16];
    ft_memcpy(CB, ICB, 16);

    const size_t n_complete_blocks = X->msg.len / BLOCK_LEN_BYTES;
    const size_t partial_block_len = X->msg.len % BLOCK_LEN_BYTES;
    for (size_t i = 0; i < n_complete_blocks; ++i) {
        uint8_t Ei[AES256_BLOCK_SIZE_BYTES];

        Cipher(CB, Ei, (uint32_t *)X->expanded_key);

        for (int j = 0; j < AES256_BLOCK_SIZE_BYTES; ++j) {
            Y->msg.data[(AES256_BLOCK_SIZE_BYTES * i) + j] = X->msg.data[(AES256_BLOCK_SIZE_BYTES * i) + j] ^ Ei[j];
        }

        if (i < n_complete_blocks - 1 || partial_block_len > 0) {
            uint32_t *counter_part = (uint32_t *)((uint8_t *)&CB + 12);
            *counter_part = BSWAP_32(BSWAP_32(*counter_part) + 1);
        }
    }

    if (partial_block_len > 0) {

        uint8_t Ei[AES256_BLOCK_SIZE_BYTES];
        Cipher(CB, Ei, (uint32_t *)X->expanded_key);

        for (size_t j = 0; j < partial_block_len; ++j) {
            Y->msg.data[(AES256_BLOCK_SIZE_BYTES * n_complete_blocks) + j] = X->msg.data[(AES256_BLOCK_SIZE_BYTES * n_complete_blocks) + j] ^ Ei[j];
        }
    }

    ft_memcpy(Y->key, X->key, sizeof(X->key));
    ft_memcpy(Y->expanded_key, X->expanded_key, sizeof(X->expanded_key));
    Y->msg.len = X->msg.len;
}

void
GCM_AE(Aes256Gcm *const P, Aes256Gcm *const C) {
    uint8_t H[AES256_BLOCK_SIZE_BYTES] = {0};
    Cipher(H, H, P->expanded_key);

    uint8_t J0[AES256_BLOCK_SIZE_BYTES] = {0};
    ft_memcpy(J0, P->iv, IV_LEN_BYTES);
    J0[15] |= 1;

    uint8_t J1[AES256_BLOCK_SIZE_BYTES] = {0};
    ft_memcpy(J1, J0, AES256_BLOCK_SIZE_BYTES);

    uint32_t *counter_part = (uint32_t *)((uint8_t *)&J1[IV_LEN_BYTES]);
    *counter_part = BSWAP_32(BSWAP_32(*counter_part) + 1);

    GCTR(J1, (Aes256Data *)P, (Aes256Data *)C);

    uint8_t Y[16] = {0};

    const size_t aad_blocks = P->aad.len / AES256_BLOCK_SIZE_BYTES;
    for (size_t i = 0; i < aad_blocks; ++i) {
        GHASH_block(Y, &P->aad.data[i * AES256_BLOCK_SIZE_BYTES], H);
    }
    const size_t aad_remainder = P->aad.len % AES256_BLOCK_SIZE_BYTES;
    if (aad_remainder > 0) {
        uint8_t padded_block[AES256_BLOCK_SIZE_BYTES] = {0};
        ft_memcpy(padded_block, P->aad.data + aad_blocks * 16, aad_remainder);
        GHASH_block(Y, padded_block, H);
    }

    const size_t msg_blocks = P->msg.len / AES256_BLOCK_SIZE_BYTES;
    for (size_t i = 0; i < msg_blocks; ++i) {
        GHASH_block(Y, &P->msg.data[i * AES256_BLOCK_SIZE_BYTES], H);
    }
    const size_t msg_remainder = P->msg.len % AES256_BLOCK_SIZE_BYTES;
    if (msg_remainder > 0) {
        uint8_t padded_block[AES256_BLOCK_SIZE_BYTES] = {0};
        ft_memcpy(padded_block, P->msg.data + msg_blocks * AES256_BLOCK_SIZE_BYTES, msg_remainder);
        GHASH_block(Y, padded_block, H);
    }

    uint64_t len_block[2] = {BSWAP_64(P->aad.len * 8), BSWAP_64(P->msg.len * 8)};
    GHASH_block(Y, (uint8_t *)len_block, H);

    uint8_t T[AES256_BLOCK_SIZE_BYTES];
    Cipher(J0, T, P->expanded_key);

    for (int i = 0; i < AES256_BLOCK_SIZE_BYTES; ++i) {
        C->tag[i] = Y[i] ^ T[i];
    }
}

int
GCM_AD(Aes256Gcm *const C, Aes256Gcm *const out) {}

bool
GCMAE_empty_message() {
    uint8_t key[32] = {0};
    uint8_t plaintext[16] = {0};

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, 0); // 0 length
    uint8_t iv[12] = {0};
    ft_memcpy(X.iv, iv, 12);
    GCM_AE(&X, &X);

    const uint8_t expected_tag[16] = {0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9, 0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b};
    for (int i = 0; i < 16; ++i) {
        if (X.tag[i] != expected_tag[i]) {
            return false;
        }
    }
    return true;
}

bool
GCMAE_one_block() {
    uint8_t key[32] = {0};
    uint8_t plaintext[16] = {0};

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, 16);
    uint8_t iv[12] = {0};
    ft_memcpy(X.iv, iv, 12);
    GCM_AE(&X, &X);

    const uint8_t expected_tag[16] = {0xd0, 0xd1, 0xc8, 0xa7, 0x99, 0x99, 0x6b, 0xf0, 0x26, 0x5b, 0x98, 0xb5, 0xd4, 0x8a, 0xb9, 0x19};
    for (int i = 0; i < 16; ++i) {
        if (X.tag[i] != expected_tag[i]) {
            return false;
        }
    }
    const uint8_t expected_ct[16] = {0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e, 0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18};
    for (int i = 0; i < 16; ++i) {
        if (X.msg.data[i] != expected_ct[i]) {
            return false;
        }
    }
    return true;
}

bool
GCMAE_multiblock() {
    uint8_t key[32] = {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
    };
    uint8_t plaintext[64] = {
        0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34,
        0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24,
        0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55,
    };

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, 64);
    uint8_t iv[12] = {
        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88,
    };
    ft_memcpy(X.iv, iv, 12);
    GCM_AE(&X, &X);

    const uint8_t expected_tag[16] = {
        0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd, 0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c,
    };
    const uint8_t expected_ct[64] = {
        0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5,
        0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 0xa7, 0xb0, 0x8b, 0x10,
        0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad,
    };

    for (int i = 0; i < 16; ++i) {
        if (X.tag[i] != expected_tag[i]) {
            return false;
        }
    }
    for (int i = 0; i < 64; ++i) {
        if (X.msg.data[i] != expected_ct[i]) {
            return false;
        }
    }
    return true;
}

bool
GCMAE_multiblock_remainder() {
    uint8_t key[32] = {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
    };
    uint8_t plaintext[60] = {
        0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53,
        0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
        0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39,
    };
    const uint8_t aad[20] = {
        0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xab, 0xad, 0xda, 0xd2,
    };
    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, 60);
    uint8_t iv[12] = {
        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88,
    };
    ft_memcpy(X.iv, iv, 12);
    X.aad.data = (uint8_t *)aad;
    X.aad.len = sizeof(aad);
    GCM_AE(&X, &X);

    const uint8_t expected_tag[16] = {
        0x76, 0xfc, 0x6e, 0xce, 0x0f, 0x4e, 0x17, 0x68, 0xcd, 0xdf, 0x88, 0x53, 0xbb, 0x2d, 0x55, 0x1b,
    };
    const uint8_t expected_ct[60] = {
        0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc,
        0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,
        0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62,
    };

    for (int i = 0; i < 16; ++i) {
        if (X.tag[i] != expected_tag[i]) {
            return false;
        }
    }
    for (int i = 0; i < 56; ++i) {
        if (X.msg.data[i] != expected_ct[i]) {
            return false;
        }
    }
    return true;
}

bool
GCTR_test_empty_input_returns_empty_cipher() {
    uint8_t key[32] = {0};
    uint8_t plaintext[1] = {0};
    uint8_t ICB[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, 0); // 0 length
    GCTR(ICB, (Aes256Data *)&X, (Aes256Data *)&X);

    return X.msg.len == 0;
}

bool
GCTR_test_all_zero_input() {
    uint8_t key[32] = {0};
    uint8_t plaintext[16] = {0};
    uint8_t ICB[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2};

    uint8_t expected[16] = {0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e, 0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18};

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, sizeof(plaintext));
    GCTR(ICB, (Aes256Data *)&X, (Aes256Data *)&X);

    return ft_memcmp(X.msg.data, expected, 16) == 0;
}

bool
GCTR_test_multiblock_no_remainder() {
    uint8_t key[32] = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
                       0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};

    uint8_t plaintext[64] = {0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34,
                             0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53, 0x2f, 0xcf, 0x0e, 0x24,
                             0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55};

    uint8_t ICB[16] = {0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88, 0x00, 0x00, 0x00, 0x02};

    uint8_t expected[64] = {0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5,
                            0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d, 0xa7, 0xb0, 0x8b, 0x10,
                            0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad};

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, sizeof(plaintext));
    GCTR(ICB, (Aes256Data *)&X, (Aes256Data *)&X);

    return ft_memcmp(X.msg.data, expected, 64) == 0;
}

bool
GCTR_test_multiblock_non_multiple_of_128() {
    uint8_t key[32] = {0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
                       0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c, 0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08};

    uint8_t plaintext[60] = {0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5, 0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a, 0x86, 0xa7, 0xa9, 0x53,
                             0x15, 0x34, 0xf7, 0xda, 0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72, 0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
                             0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25, 0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57, 0xba, 0x63, 0x7b, 0x39};

    uint8_t ICB[16] = {0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad, 0xde, 0xca, 0xf8, 0x88, 0x00, 0x00, 0x00, 0x02};

    uint8_t expected_ciphertext[60] = {0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07, 0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d, 0x64, 0x3a, 0x8c, 0xdc,
                                       0xbf, 0xe5, 0xc0, 0xc9, 0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa, 0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,
                                       0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38, 0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a, 0xbc, 0xc9, 0xf6, 0x62};

    Aes256Gcm X = {0};
    AES256_Init((Aes256Data *)&X, key, plaintext, sizeof(plaintext));
    GCTR(ICB, (Aes256Data *)&X, (Aes256Data *)&X);

    return ft_memcmp(X.msg.data, expected_ciphertext, 60) == 0;
}

bool
GHASH_test_empty_input_returns_zero() {
    uint8_t t[16] = {0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x81, 0x2c, 0x3b, 0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e};
    uint8_t out[16] = {0};
    GHASH(t, NULL, 0, out);

    for (int i = 0; i < 16; ++i) {
        if (out[i] != 0) {
            return false;
        }
    }
    return true;
}

bool
GHASH_test_two_blocks() {
    uint8_t t[16] = {0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x8a, 0x2c, 0x3b, 0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e};
    uint8_t data[32] = {0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80};
    uint8_t out[16] = {0};
    GHASH(t, data, sizeof(data), out);

    const uint8_t expected[16] = {0xf3, 0x8c, 0xbb, 0x1a, 0xd6, 0x92, 0x23, 0xdc, 0xc3, 0x45, 0x7a, 0xe5, 0xb6, 0xb0, 0xf8, 0x85};

    for (int i = 0; i < 16; ++i) {
        if (out[i] != expected[i]) {
            return false;
        }
    }
    return true;
}
